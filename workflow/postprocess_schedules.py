#!/usr/bin/env python
"""
process_detection_results: Compute Detection Probabilities and Extract Metrics
==============================================================================

This script processes observation plans generated by M4OPT, computing detection
probabilities and extracting relevant optimization metrics.

It supports both command-line arguments and `.ini` configuration files.

Usage
-----
From the command line:

    python process_detection_results.py --data-dir data

Or using a config file:

    python process_detection_results.py --config config.ini
"""

import argparse
import configparser
import logging
import sys
from pathlib import Path

from astropy.table import QTable
from detection_probability import get_detection_probability_known_position
from ligo.skymap.util.progress import progress_map


def parse_arguments():
    """
    Parse command-line arguments or load them from a .ini configuration file.

    Returns
    -------
    argparse.Namespace
        The parsed arguments.
    """
    parser = argparse.ArgumentParser(description="Post-process M4OPT ECSV plans.")
    parser.add_argument("--config", type=str, help="Path to .ini configuration file")

    # Minimal parse to detect config
    args, remaining_args = parser.parse_known_args()

    if args.config:
        config = configparser.ConfigParser()
        config.read(args.config)
        cfg = config["params"]
        return argparse.Namespace(
            data_dir=cfg.get("data_dir", fallback="data"),
            input_file=cfg.get("input_file", fallback="observing-scenarios.ecsv"),
            output_file=cfg.get("output_file", fallback="events.ecsv"),
        )

    # Full CLI parsing if no config
    parser.add_argument(
        "--data-dir", type=str, default="data", help="Directory containing ECSV files"
    )
    parser.add_argument(
        "--input-file",
        type=str,
        default="observing-scenarios.ecsv",
        help="Input summary table",
    )
    parser.add_argument(
        "--output-file", type=str, default="events.ecsv", help="Output filename"
    )

    return parser.parse_args(remaining_args)


def setup_logging():
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s",
        handlers=[logging.StreamHandler(sys.stdout)],
        force=True,
    )


def process(row, base_path):
    run = row["run"]
    event_id = row["coinc_event_id"]
    plan_file = base_path / run / f"{event_id}.ecsv"
    plan = QTable.read(plan_file)
    plan_args = {**plan.meta["args"]}
    plan_args.pop("skymap", None)
    return (
        get_detection_probability_known_position(plan, row, plan_args),
        plan.meta.get("objective_value"),
        plan.meta.get("best_bound"),
        plan.meta.get("solution_status"),
        plan.meta.get("solution_time"),
        len(plan[plan["action"] == "observe"]) // plan_args["visits"],
    )


def main():
    args = parse_arguments()
    setup_logging()

    base_path = Path(args.data_dir)
    input_path = base_path / args.input_file
    output_path = base_path / args.output_file

    logging.info(f"Reading input table from {input_path}")
    table = QTable.read(input_path)

    logging.info("Processing observation plans...")
    (
        table["detection_probability_known_position"],
        table["objective_value"],
        table["best_bound"],
        table["solution_status"],
        table["solution_time"],
        table["num_fields"],
    ) = zip(*progress_map(lambda row: process(row, base_path), table))

    logging.info(f"Writing results to {output_path}")
    table.write(output_path, overwrite=True)


if __name__ == "__main__":
    main()
